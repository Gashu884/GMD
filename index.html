<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Image Histogram Thresholding Demo</title>
  <script src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background: #f6f6f6;
    }
    h1 {
      margin-bottom: 0.5rem;
    }
    .panel {
      background: #fff;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .canvas-grid {
      display: grid;
      gap: 20px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      align-items: start;
    }
    canvas {
      background: #222;
      border-radius: 4px;
      max-width: 100%;
    }
    .label {
      font-weight: bold;
      margin-bottom: 8px;
    }
    #status {
      color: #555;
    }
    #count-result {
      font-size: 1.1rem;
      font-weight: bold;
    }
    button {
      padding: 8px 14px;
      border: none;
      border-radius: 4px;
      background: #1976d2;
      color: #fff;
      cursor: pointer;
    }
    button:disabled {
      background: #9e9e9e;
      cursor: default;
    }
    input[type="range"] {
      width: 220px;
    }
  </style>
</head>
<body>
  <h1>GMDカウント</h1>

  <div class="panel">
    <div class="controls">
      <label>
        画像を選択:
        <input type="file" id="file-input" accept="image/*">
      </label>
      <label>
        閾値: <span id="threshold-value">128</span>
        <input type="range" id="threshold-slider" min="0" max="255" value="128" disabled>
      </label>
      <label>
        ノイズ除去 (最小面積):
        <input type="number" id="min-area" value="50" min="0" step="10" disabled>
      </label>
      <button id="apply-threshold" disabled>閾値を適用</button>
      <button id="auto-threshold" disabled>自動閾値 (大津)</button>
      <button id="fill-holes" disabled>穴埋め (Fill Holes)</button>
    </div>
    <p id="status">OpenCV.js のロードを待機しています...</p>
    <p id="count-result"></p>
  </div>

  <div class="panel">
    <div class="canvas-grid">
      <div>
        <div class="label">元画像</div>
        <canvas id="canvas-original"></canvas>
      </div>
      <div>
        <div class="label">二値マスク</div>
        <canvas id="canvas-mask"></canvas>
      </div>
      <div>
        <div class="label">検出結果</div>
        <canvas id="canvas-annotated"></canvas>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="label">ヒストグラム</div>
    <canvas id="histogram-chart" height="160"></canvas>
  </div>

  <div class="panel">
    <div class="controls">
      <label>
        スケール (単位/px):
        <input type="number" id="scale-value" value="1" min="0" step="0.01" disabled>
      </label>
      <label>
        対象サイズ (最小):
        <input type="number" id="min-size" value="0" min="0" step="0.1" disabled>
      </label>
      <label>
        対象サイズ (最大):
        <input type="number" id="max-size" value="0" min="0" step="0.1" disabled placeholder="0で制限なし">
      </label>
    </div>
  </div>

  <img id="hidden-image" style="display:none;" alt="source">
  <canvas id="hidden-canvas" style="display:none;"></canvas>

  <script>
    let cvReady = false;
    let chartInstance = null;

    let srcMat, grayMat, invertedMat, blurMat, currentBinaryMat, annotatedMat;

    const fileInput = document.getElementById('file-input');
    const thresholdSlider = document.getElementById('threshold-slider');
    const thresholdValueLabel = document.getElementById('threshold-value');
    const minAreaInput = document.getElementById('min-area');
    const applyButton = document.getElementById('apply-threshold');
    const autoButton = document.getElementById('auto-threshold');
    const fillButton = document.getElementById('fill-holes');
    const statusLabel = document.getElementById('status');
    const countLabel = document.getElementById('count-result');
    const hiddenImage = document.getElementById('hidden-image');
    const hiddenCanvas = document.getElementById('hidden-canvas');
    const scaleInput = document.getElementById('scale-value');
    const minSizeInput = document.getElementById('min-size');
    const maxSizeInput = document.getElementById('max-size');

    window.Module = {
      onRuntimeInitialized() {
        onOpenCvReady();
      }
    };

    function enableControls(enabled) {
      thresholdSlider.disabled = !enabled;
      minAreaInput.disabled = !enabled;
      applyButton.disabled = !enabled;
      autoButton.disabled = !enabled;
      fillButton.disabled = !enabled;
      scaleInput.disabled = !enabled;
      minSizeInput.disabled = !enabled;
      maxSizeInput.disabled = !enabled;
    }

    function cleanupMats() {
      [srcMat, grayMat, invertedMat, blurMat, currentBinaryMat, annotatedMat].forEach(mat => {
        if (mat) {
          mat.delete();
        }
      });
      srcMat = grayMat = invertedMat = blurMat = currentBinaryMat = annotatedMat = null;
    }

    function drawMat(mat, canvasId) {
      cv.imshow(canvasId, mat);
    }

    function updateHistogram(gray) {
      const histSize = 256;
      const hist = new cv.Mat();
      const mask = new cv.Mat();
      const channels = [0];
      const ranges = [0, 256];
      cv.calcHist(gray, channels, mask, hist, [histSize], ranges);
      const values = Array.from({ length: histSize }, (_, i) => hist.data32F[i]);

      if (chartInstance) {
        chartInstance.destroy();
      }

      const ctx = document.getElementById('histogram-chart').getContext('2d');
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [...Array(histSize).keys()],
          datasets: [{
            label: 'Intensity Histogram',
            data: values,
            borderColor: '#1976d2',
            backgroundColor: 'rgba(25, 118, 210, 0.2)',
            pointRadius: 0,
            borderWidth: 2,
            fill: true,
          }]
        },
        options: {
          animation: false,
          scales: {
            x: {
              ticks: {
                stepSize: 10
              },
              minor: {
                tickLength: 4
              },
              grid: {
                display: true
              }
            },
            y: {
              grid: {
                display: true
              }
            }
          },
          plugins: {
            legend: {
              display: false
            }
          }
        }
      });

      hist.delete();
      mask.delete();
    }

    function drawThresholdLine(threshold) {
      if (!chartInstance) return;
      const annotationDataset = {
        label: 'Threshold',
        data: chartInstance.data.labels.map((label) => (label === threshold ? Math.max(...chartInstance.data.datasets[0].data) : null)),
        borderColor: '#d32f2f',
        borderWidth: 1,
        pointRadius: 0,
      };
      const existing = chartInstance.data.datasets.findIndex(ds => ds.label === 'Threshold');
      if (existing >= 0) {
        chartInstance.data.datasets.splice(existing, 1, annotationDataset);
      } else {
        chartInstance.data.datasets.push(annotationDataset);
      }
      chartInstance.update();
    }

    function processThreshold(threshold, auto = false) {
      if (!invertedMat) return;

      const minArea = Math.max(parseInt(minAreaInput.value, 10) || 0, 0);

      if (blurMat) blurMat.delete();
      blurMat = new cv.Mat();
      cv.GaussianBlur(invertedMat, blurMat, new cv.Size(5, 5), 0);

      const thresholdType = cv.THRESH_BINARY;
      if (auto) {
        const otsuResult = new cv.Mat();
        threshold = cv.threshold(blurMat, otsuResult, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
        otsuResult.delete();
        threshold = Math.round(threshold);
        thresholdSlider.value = threshold;
        thresholdValueLabel.textContent = threshold;
      } else {
        threshold = Math.max(0, Math.min(255, threshold));
      }

      if (currentBinaryMat) currentBinaryMat.delete();
      currentBinaryMat = new cv.Mat();
      cv.threshold(blurMat, currentBinaryMat, threshold, 255, thresholdType);

      const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
      cv.morphologyEx(currentBinaryMat, currentBinaryMat, cv.MORPH_OPEN, kernel);
      kernel.delete();

      drawMat(currentBinaryMat, 'canvas-mask');

      countObjects(minArea);

      drawThresholdLine(threshold);
    }

    function fillHoles() {
      if (!currentBinaryMat) return;
      const holes = new cv.Mat();
      cv.bitwise_not(currentBinaryMat, holes);
      const mask = new cv.Mat(holes.rows + 2, holes.cols + 2, cv.CV_8UC1, new cv.Scalar(0));
      cv.floodFill(holes, mask, new cv.Point(0, 0), new cv.Scalar(0));
      cv.bitwise_not(holes, holes);
      cv.bitwise_or(currentBinaryMat, holes, currentBinaryMat);
      holes.delete();
      mask.delete();
      drawMat(currentBinaryMat, 'canvas-mask');
      countObjects(Math.max(parseInt(minAreaInput.value, 10) || 0, 0));
    }

    function countObjects(minArea) {
      if (!currentBinaryMat || !srcMat) return;
      const scale = Math.max(parseFloat(scaleInput.value) || 0, 0);
      const minSize = Math.max(parseFloat(minSizeInput.value) || 0, 0);
      const maxSizeRaw = Math.max(parseFloat(maxSizeInput.value) || 0, 0);
      const limitedMax = maxSizeRaw === 0 ? Infinity : maxSizeRaw;

      const labels = new cv.Mat();
      const stats = new cv.Mat();
      const centroids = new cv.Mat();
      const numComponents = cv.connectedComponentsWithStats(currentBinaryMat, labels, stats, centroids);

      if (annotatedMat) annotatedMat.delete();
      annotatedMat = srcMat.clone();

      let count = 0;
      for (let i = 1; i < numComponents; i++) {
        const area = stats.intAt(i, cv.CC_STAT_AREA);
        if (area < minArea) continue;
        const x = stats.intAt(i, cv.CC_STAT_LEFT);
        const y = stats.intAt(i, cv.CC_STAT_TOP);
        const w = stats.intAt(i, cv.CC_STAT_WIDTH);
        const h = stats.intAt(i, cv.CC_STAT_HEIGHT);
        const cx = centroids.doubleAt(i, 0);
        const cy = centroids.doubleAt(i, 1);
        const diameterPx = Math.sqrt((4 * area) / Math.PI);
        const diameterReal = scale > 0 ? diameterPx * scale : diameterPx;
        if (diameterReal < minSize || diameterReal > limitedMax) continue;
        cv.rectangle(annotatedMat, new cv.Point(x, y), new cv.Point(x + w, y + h), new cv.Scalar(0, 255, 0, 255), 2);
        cv.circle(annotatedMat, new cv.Point(Math.round(cx), Math.round(cy)), 3, new cv.Scalar(0, 0, 255, 255), -1);
        count++;
      }

      drawMat(annotatedMat, 'canvas-annotated');
      const unitLabel = scale > 0 ? '(単位換算)' : '(ピクセル)';
      countLabel.textContent = `検出数: ${count} / スケール${unitLabel}: ${scale || 1}`;

      labels.delete();
      stats.delete();
      centroids.delete();
    }

    function handleFile(file) {
      cleanupMats();
      countLabel.textContent = '';
      statusLabel.textContent = '画像を読み込んでいます...';

      const reader = new FileReader();
      reader.onload = (event) => {
        hiddenImage.onload = () => {
          hiddenCanvas.width = hiddenImage.width;
          hiddenCanvas.height = hiddenImage.height;
          const ctx = hiddenCanvas.getContext('2d');
          ctx.drawImage(hiddenImage, 0, 0);

          srcMat = cv.imread(hiddenCanvas);
          grayMat = new cv.Mat();
          cv.cvtColor(srcMat, grayMat, cv.COLOR_RGBA2GRAY);
          invertedMat = new cv.Mat();
          cv.bitwise_not(grayMat, invertedMat);

          drawMat(srcMat, 'canvas-original');
          drawMat(invertedMat, 'canvas-mask');
          drawMat(srcMat, 'canvas-annotated');

          updateHistogram(invertedMat);
          drawThresholdLine(parseInt(thresholdSlider.value, 10));

          statusLabel.textContent = '閾値を調整して対象を検出してください。';
          enableControls(true);
          fillButton.disabled = true; // 閾値適用まで無効
        };
        hiddenImage.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;
      if (!cvReady) {
        statusLabel.textContent = 'OpenCV.js の初期化中です。少し待ってから再度お試しください。';
        return;
      }
      handleFile(file);
    });

    thresholdSlider.addEventListener('input', (event) => {
      const value = parseInt(event.target.value, 10);
      thresholdValueLabel.textContent = value;
    });

    applyButton.addEventListener('click', () => {
      const threshold = parseInt(thresholdSlider.value, 10);
      processThreshold(threshold, false);
      fillButton.disabled = false;
    });

    autoButton.addEventListener('click', () => {
      processThreshold(0, true);
      fillButton.disabled = false;
    });

    minAreaInput.addEventListener('change', () => {
      countObjects(Math.max(parseInt(minAreaInput.value, 10) || 0, 0));
    });

    fillButton.addEventListener('click', () => {
      fillHoles();
    });

    [scaleInput, minSizeInput, maxSizeInput].forEach(input => {
      input.addEventListener('change', () => {
        countObjects(Math.max(parseInt(minAreaInput.value, 10) || 0, 0));
      });
    });

    function onOpenCvReady() {
      cvReady = true;
      statusLabel.textContent = '画像を読み込んで解析を開始できます。';
      enableControls(false);
    }

    window.addEventListener('beforeunload', () => {
      cleanupMats();
    });
  </script>
</body>
</html>

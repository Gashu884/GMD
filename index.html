<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <title>Image Histogram Thresholding Demo</title>
  <script src="https://docs.opencv.org/4.x/opencv.js" type="text/javascript"></script>
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <style>
    body {
      font-family: sans-serif;
      margin: 20px;
      background: #f6f6f6;
    }
    h1 {
      margin-bottom: 0.5rem;
    }
    .panel {
      background: #fff;
      padding: 16px;
      border-radius: 8px;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.1);
      margin-bottom: 20px;
    }
    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      align-items: center;
    }
    .canvas-grid {
      display: grid;
      gap: 20px;
      grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
      align-items: start;
    }
    canvas {
      background: #222;
      border-radius: 4px;
      max-width: 100%;
    }
    .label {
      font-weight: bold;
      margin-bottom: 8px;
    }
    #status {
      color: #555;
    }
    #count-result {
      font-size: 1.1rem;
      font-weight: bold;
    }
    button {
      padding: 8px 14px;
      border: none;
      border-radius: 4px;
      background: #1976d2;
      color: #fff;
      cursor: pointer;
    }
    button:disabled {
      background: #9e9e9e;
      cursor: default;
    }
    input[type="range"] {
      width: 220px;
    }
  </style>
</head>
<body>
  <h1>GMDカウント</h1>

  <div class="panel">
    <div class="controls">
      <label>
        画像を選択:
        <input type="file" id="file-input" accept="image/*">
      </label>
      <label>
        閾値: <span id="threshold-value">128</span>
        <input type="range" id="threshold-slider" min="0" max="255" value="128" disabled>
      </label>
      <label>
        ノイズ除去 (最小面積):
        <input type="number" id="min-area" value="50" min="0" step="10" disabled>
      </label>
      <button id="apply-threshold" disabled>閾値を適用</button>
      <button id="auto-threshold" disabled>自動閾値 (大津)</button>
    </div>
    <p id="status">OpenCV.js のロードを待機しています...</p>
    <p id="count-result"></p>
  </div>

  <div class="panel">
    <div class="canvas-grid">
      <div>
        <div class="label">元画像</div>
        <canvas id="canvas-original"></canvas>
      </div>
      <div>
        <div class="label">二値マスク</div>
        <canvas id="canvas-mask"></canvas>
      </div>
      <div>
        <div class="label">検出結果</div>
        <canvas id="canvas-annotated"></canvas>
      </div>
    </div>
  </div>

  <div class="panel">
    <div class="label">ヒストグラム</div>
    <canvas id="histogram-chart" height="160"></canvas>
  </div>

  <img id="hidden-image" style="display:none;" alt="source">
  <canvas id="hidden-canvas" style="display:none;"></canvas>

  <script>
    let cvReady = false;
    let chartInstance = null;

    let srcMat, grayMat, blurMat, binaryMat, cleanedMat, annotatedMat;

    const fileInput = document.getElementById('file-input');
    const thresholdSlider = document.getElementById('threshold-slider');
    const thresholdValueLabel = document.getElementById('threshold-value');
    const minAreaInput = document.getElementById('min-area');
    const applyButton = document.getElementById('apply-threshold');
    const autoButton = document.getElementById('auto-threshold');
    const statusLabel = document.getElementById('status');
    const countLabel = document.getElementById('count-result');
    const hiddenImage = document.getElementById('hidden-image');
    const hiddenCanvas = document.getElementById('hidden-canvas');

    window.Module = {
      onRuntimeInitialized() {
        onOpenCvReady();
      }
    };

    function enableControls(enabled) {
      thresholdSlider.disabled = !enabled;
      minAreaInput.disabled = !enabled;
      applyButton.disabled = !enabled;
      autoButton.disabled = !enabled;
    }

    function cleanupMats() {
      [srcMat, grayMat, blurMat, binaryMat, cleanedMat, annotatedMat].forEach(mat => {
        if (mat) {
          mat.delete();
        }
      });
      srcMat = grayMat = blurMat = binaryMat = cleanedMat = annotatedMat = null;
    }

    function drawMat(mat, canvasId) {
      cv.imshow(canvasId, mat);
    }

    function updateHistogram(gray) {
      const histSize = 256;
      const hist = new cv.Mat();
      const mask = new cv.Mat();
      const channels = [0];
      const ranges = [0, 256];
      cv.calcHist(gray, channels, mask, hist, [histSize], ranges);
      const values = Array.from({ length: histSize }, (_, i) => hist.data32F[i]);

      if (chartInstance) {
        chartInstance.destroy();
      }

      const ctx = document.getElementById('histogram-chart').getContext('2d');
      chartInstance = new Chart(ctx, {
        type: 'line',
        data: {
          labels: [...Array(histSize).keys()],
          datasets: [{
            label: 'Intensity Histogram',
            data: values,
            borderColor: '#1976d2',
            backgroundColor: 'rgba(25, 118, 210, 0.2)',
            pointRadius: 0,
            borderWidth: 2,
            fill: true,
          }]
        },
        options: {
          animation: false,
          scales: {
            x: {
              ticks: {
                stepSize: 10
              },
              minor: {
                tickLength: 4
              },
              grid: {
                display: true
              }
            },
            y: {
              grid: {
                display: true
              }
            }
          },
          plugins: {
            legend: {
              display: false
            }
          }
        }
      });

      hist.delete();
      mask.delete();
    }

    function drawThresholdLine(threshold) {
      if (!chartInstance) return;
      const annotationDataset = {
        label: 'Threshold',
        data: chartInstance.data.labels.map((label) => (label === threshold ? Math.max(...chartInstance.data.datasets[0].data) : null)),
        borderColor: '#d32f2f',
        borderWidth: 1,
        pointRadius: 0,
      };
      const existing = chartInstance.data.datasets.findIndex(ds => ds.label === 'Threshold');
      if (existing >= 0) {
        chartInstance.data.datasets.splice(existing, 1, annotationDataset);
      } else {
        chartInstance.data.datasets.push(annotationDataset);
      }
      chartInstance.update();
    }

    function processImage(threshold, auto = false) {
      if (!grayMat) return;

      const minArea = Math.max(parseInt(minAreaInput.value, 10) || 0, 0);

      if (blurMat) blurMat.delete();
      blurMat = new cv.Mat();
      cv.GaussianBlur(grayMat, blurMat, new cv.Size(5, 5), 0);

      const thresholdType = cv.THRESH_BINARY;
      if (auto) {
        const otsuResult = new cv.Mat();
        threshold = cv.threshold(blurMat, otsuResult, 0, 255, cv.THRESH_BINARY + cv.THRESH_OTSU);
        otsuResult.delete();
        threshold = Math.round(threshold);
        thresholdSlider.value = threshold;
        thresholdValueLabel.textContent = threshold;
      } else {
        threshold = Math.max(0, Math.min(255, threshold));
      }

      if (binaryMat) binaryMat.delete();
      binaryMat = new cv.Mat();
      cv.threshold(blurMat, binaryMat, threshold, 255, thresholdType);

      const kernel = cv.getStructuringElement(cv.MORPH_ELLIPSE, new cv.Size(3, 3));
      if (cleanedMat) cleanedMat.delete();
      cleanedMat = new cv.Mat();
      cv.morphologyEx(binaryMat, cleanedMat, cv.MORPH_OPEN, kernel);
      kernel.delete();

      drawMat(cleanedMat, 'canvas-mask');

      const labels = new cv.Mat();
      const stats = new cv.Mat();
      const centroids = new cv.Mat();
      const numComponents = cv.connectedComponentsWithStats(cleanedMat, labels, stats, centroids);

      if (annotatedMat) annotatedMat.delete();
      annotatedMat = srcMat.clone();

      let count = 0;
      for (let i = 1; i < numComponents; i++) {
        const area = stats.intAt(i, cv.CC_STAT_AREA);
        if (area < minArea) {
          continue;
        }
        const x = stats.intAt(i, cv.CC_STAT_LEFT);
        const y = stats.intAt(i, cv.CC_STAT_TOP);
        const w = stats.intAt(i, cv.CC_STAT_WIDTH);
        const h = stats.intAt(i, cv.CC_STAT_HEIGHT);
        const cx = centroids.doubleAt(i, 0);
        const cy = centroids.doubleAt(i, 1);
        const color = new cv.Scalar(0, 255, 0, 255);
        cv.rectangle(annotatedMat, new cv.Point(x, y), new cv.Point(x + w, y + h), color, 2);
        cv.circle(annotatedMat, new cv.Point(Math.round(cx), Math.round(cy)), 3, new cv.Scalar(0, 0, 255, 255), -1);
        count++;
      }

      drawMat(annotatedMat, 'canvas-annotated');
      countLabel.textContent = `検出した対象数: ${count} / 閾値: ${threshold}`;

      labels.delete();
      stats.delete();
      centroids.delete();

      drawThresholdLine(threshold);
    }

    function handleFile(file) {
      cleanupMats();
      countLabel.textContent = '';
      statusLabel.textContent = '画像を読み込んでいます...';

      const reader = new FileReader();
      reader.onload = (event) => {
        hiddenImage.onload = () => {
          hiddenCanvas.width = hiddenImage.width;
          hiddenCanvas.height = hiddenImage.height;
          const ctx = hiddenCanvas.getContext('2d');
          ctx.drawImage(hiddenImage, 0, 0);

          srcMat = cv.imread(hiddenCanvas);
          grayMat = new cv.Mat();
          cv.cvtColor(srcMat, grayMat, cv.COLOR_RGBA2GRAY);

          drawMat(srcMat, 'canvas-original');
          drawMat(grayMat, 'canvas-mask'); // 初期状態はグレースケールを表示
          drawMat(srcMat, 'canvas-annotated');

          updateHistogram(grayMat);
          drawThresholdLine(parseInt(thresholdSlider.value, 10));

          statusLabel.textContent = '閾値を調整して対象を検出してください。';
          enableControls(true);
        };
        hiddenImage.src = event.target.result;
      };
      reader.readAsDataURL(file);
    }

    fileInput.addEventListener('change', (event) => {
      const file = event.target.files[0];
      if (!file) return;
      if (!cvReady) {
        statusLabel.textContent = 'OpenCV.js の初期化中です。少し待ってから再度お試しください。';
        return;
      }
      handleFile(file);
    });

    thresholdSlider.addEventListener('input', (event) => {
      const value = parseInt(event.target.value, 10);
      thresholdValueLabel.textContent = value;
    });

    applyButton.addEventListener('click', () => {
      const threshold = parseInt(thresholdSlider.value, 10);
      processImage(threshold, false);
    });

    autoButton.addEventListener('click', () => {
      processImage(0, true);
    });

    minAreaInput.addEventListener('change', () => {
      const threshold = parseInt(thresholdSlider.value, 10);
      processImage(threshold, false);
    });

    function onOpenCvReady() {
      cvReady = true;
      statusLabel.textContent = '画像を読み込んで解析を開始できます。';
      enableControls(false);
    }

    window.addEventListener('beforeunload', () => {
      cleanupMats();
    });
  </script>
</body>
</html>
